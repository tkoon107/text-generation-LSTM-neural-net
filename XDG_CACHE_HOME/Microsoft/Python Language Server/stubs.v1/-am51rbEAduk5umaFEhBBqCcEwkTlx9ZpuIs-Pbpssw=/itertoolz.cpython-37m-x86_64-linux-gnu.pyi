import builtins as _mod_builtins
import collections as _mod_collections
import itertools as _mod_itertools
import operator as _mod_operator
import random as _mod_random

Random = _mod_random.Random
__all__ = _mod_builtins.list()
__builtins__ = {}
__doc__ = None
__file__ = '/home/trevor/anaconda3/lib/python3.7/site-packages/cytoolz/itertoolz.cpython-37m-x86_64-linux-gnu.so'
__name__ = 'cytoolz.itertoolz'
__package__ = 'cytoolz'
__pyx_capi__ = _mod_builtins.dict()
def __pyx_unpickle__getter_null(__pyx_type, __pyx_checksum, __pyx_state):
    '__pyx_unpickle__getter_null(__pyx_type, long __pyx_checksum, __pyx_state)'
    pass

def __reduce_cython__(self):
    'random_sample.__reduce_cython__(self)'
    pass

def __setstate_cython__(self, __pyx_state):
    'random_sample.__setstate_cython__(self, __pyx_state)'
    pass

__test__ = _mod_builtins.dict()
class _diff_identity(_mod_builtins.object):
    __class__ = _diff_identity
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _diff_identity()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_diff_identity.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_diff_identity.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _diff_key(_mod_builtins.object):
    __class__ = _diff_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _diff_key()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_diff_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_diff_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _getter_index(_mod_builtins.object):
    def __call__(self, *args, **kwargs):
        'Call self as a function.'
        pass
    
    __class__ = _getter_index
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        '_getter_index.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_getter_index.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _getter_list(_mod_builtins.object):
    def __call__(self, *args, **kwargs):
        'Call self as a function.'
        pass
    
    __class__ = _getter_list
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        '_getter_list.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_getter_list.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _getter_null(_mod_builtins.object):
    def __call__(self, *args, **kwargs):
        'Call self as a function.'
        pass
    
    __class__ = _getter_null
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        '_getter_null.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_getter_null.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _inner_join(_join):
    __class__ = _inner_join
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __next__(self):
        pass
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_inner_join.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_inner_join.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _inner_join_index(_inner_join):
    __class__ = _inner_join_index
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_inner_join_index.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_inner_join_index.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _inner_join_indices(_inner_join):
    __class__ = _inner_join_indices
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_inner_join_indices.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_inner_join_indices.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _inner_join_key(_inner_join):
    __class__ = _inner_join_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_inner_join_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_inner_join_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _join(_mod_builtins.object):
    __class__ = _join
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _join()
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_join.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_join.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _left_outer_join(_join):
    __class__ = _left_outer_join
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __next__(self):
        pass
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_left_outer_join.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_left_outer_join.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _left_outer_join_index(_left_outer_join):
    __class__ = _left_outer_join_index
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_left_outer_join_index.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_left_outer_join_index.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _left_outer_join_indices(_left_outer_join):
    __class__ = _left_outer_join_indices
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_left_outer_join_indices.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_left_outer_join_indices.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _left_outer_join_key(_left_outer_join):
    __class__ = _left_outer_join_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_left_outer_join_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_left_outer_join_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _merge_sorted(_mod_builtins.object):
    __class__ = _merge_sorted
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _merge_sorted()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_merge_sorted.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_merge_sorted.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _merge_sorted_key(_mod_builtins.object):
    __class__ = _merge_sorted_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _merge_sorted_key()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_merge_sorted_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_merge_sorted_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _outer_join(_join):
    __class__ = _outer_join
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __next__(self):
        pass
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_outer_join.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_outer_join.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _outer_join_index(_outer_join):
    __class__ = _outer_join_index
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_outer_join_index.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_outer_join_index.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _outer_join_indices(_outer_join):
    __class__ = _outer_join_indices
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_outer_join_indices.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_outer_join_indices.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _outer_join_key(_outer_join):
    __class__ = _outer_join_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_outer_join_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_outer_join_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _pluck_index(_mod_builtins.object):
    __class__ = _pluck_index
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _pluck_index()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_pluck_index.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_pluck_index.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _pluck_index_default(_mod_builtins.object):
    __class__ = _pluck_index_default
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _pluck_index_default()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_pluck_index_default.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_pluck_index_default.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _pluck_list(_mod_builtins.object):
    __class__ = _pluck_list
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _pluck_list()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_pluck_list.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_pluck_list.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _pluck_list_default(_mod_builtins.object):
    __class__ = _pluck_list_default
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _pluck_list_default()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_pluck_list_default.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_pluck_list_default.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _right_outer_join(_join):
    __class__ = _right_outer_join
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __next__(self):
        pass
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_right_outer_join.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_right_outer_join.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _right_outer_join_index(_right_outer_join):
    __class__ = _right_outer_join_index
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_right_outer_join_index.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_right_outer_join_index.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _right_outer_join_indices(_right_outer_join):
    __class__ = _right_outer_join_indices
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_right_outer_join_indices.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_right_outer_join_indices.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _right_outer_join_key(_right_outer_join):
    __class__ = _right_outer_join_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        '_right_outer_join_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_right_outer_join_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _unique_identity(_mod_builtins.object):
    __class__ = _unique_identity
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _unique_identity()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_unique_identity.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_unique_identity.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _unique_key(_mod_builtins.object):
    __class__ = _unique_key
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return _unique_key()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        '_unique_key.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        '_unique_key.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class accumulate(_mod_builtins.object):
    " accumulate(binop, seq, initial='__no__default__')\n\n    Repeatedly apply binary function to a sequence, accumulating results\n\n    >>> from operator import add, mul\n    >>> list(accumulate(add, [1, 2, 3, 4, 5]))\n    [1, 3, 6, 10, 15]\n    >>> list(accumulate(mul, [1, 2, 3, 4, 5]))\n    [1, 2, 6, 24, 120]\n\n    Accumulate is similar to ``reduce`` and is good for making functions like\n    cumulative sum:\n\n    >>> from functools import partial, reduce\n    >>> sum    = partial(reduce, add)\n    >>> cumsum = partial(accumulate, add)\n\n    Accumulate also takes an optional argument that will be used as the first\n    value. This is similar to reduce.\n\n    >>> list(accumulate(add, [1, 2, 3], -1))\n    [-1, 0, 2, 5]\n    >>> list(accumulate(add, [], 1))\n    [1]\n\n    See Also:\n        itertools.accumulate :  In standard itertools for Python 3.2+\n    "
    __class__ = accumulate
    def __init__(self, binop, seq, initial='__no__default__'):
        " accumulate(binop, seq, initial='__no__default__')\n\n    Repeatedly apply binary function to a sequence, accumulating results\n\n    >>> from operator import add, mul\n    >>> list(accumulate(add, [1, 2, 3, 4, 5]))\n    [1, 3, 6, 10, 15]\n    >>> list(accumulate(mul, [1, 2, 3, 4, 5]))\n    [1, 2, 6, 24, 120]\n\n    Accumulate is similar to ``reduce`` and is good for making functions like\n    cumulative sum:\n\n    >>> from functools import partial, reduce\n    >>> sum    = partial(reduce, add)\n    >>> cumsum = partial(accumulate, add)\n\n    Accumulate also takes an optional argument that will be used as the first\n    value. This is similar to reduce.\n\n    >>> list(accumulate(add, [1, 2, 3], -1))\n    [-1, 0, 2, 5]\n    >>> list(accumulate(add, [], 1))\n    [1]\n\n    See Also:\n        itertools.accumulate :  In standard itertools for Python 3.2+\n    "
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return accumulate()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'accumulate.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'accumulate.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

chain = _mod_itertools.chain
def concat(seqs):
    'concat(seqs)\n\n    Concatenate zero or more iterables, any of which may be infinite.\n\n    An infinite sequence will prevent the rest of the arguments from\n    being included.\n\n    We use chain.from_iterable rather than ``chain(*seqs)`` so that seqs\n    can be a generator.\n\n    >>> list(concat([[], [1], [2, 3]]))\n    [1, 2, 3]\n\n    See also:\n        itertools.chain.from_iterable  equivalent\n    '
    pass

def concatv(*seqs):
    'concatv(*seqs)\n\n    Variadic version of concat\n\n    >>> list(concatv([], ["a"], ["b", "c"]))\n    [\'a\', \'b\', \'c\']\n\n    See also:\n        itertools.chain\n    '
    pass

def cons(el, seq):
    'cons(el, seq)\n\n    Add el to beginning of (possibly infinite) sequence seq.\n\n    >>> list(cons(1, [2, 3]))\n    [1, 2, 3]\n    '
    pass

def count(seq):
    'count(seq)\n\n    Count the number of items in seq\n\n    Like the builtin ``len`` but works on lazy sequencies.\n\n    Not to be confused with ``itertools.count``\n\n    See also:\n        len\n    '
    pass

deque = _mod_collections.deque
def diff(*seqs, **kwargs):
    "diff(*seqs, **kwargs)\n\n    Return those items that differ between sequences\n\n    >>> list(diff([1, 2, 3], [1, 2, 10, 100]))\n    [(3, 10)]\n\n    Shorter sequences may be padded with a ``default`` value:\n\n    >>> list(diff([1, 2, 3], [1, 2, 10, 100], default=None))\n    [(3, 10), (None, 100)]\n\n    A ``key`` function may also be applied to each item to use during\n    comparisons:\n\n    >>> list(diff(['apples', 'bananas'], ['Apples', 'Oranges'], key=str.lower))\n    [('bananas', 'Oranges')]\n    "
    pass

def drop(n, seq):
    'drop(Py_ssize_t n, seq)\n\n    The sequence following the first n elements\n\n    >>> list(drop(2, [10, 20, 30, 40, 50]))\n    [30, 40, 50]\n\n    See Also:\n        take\n        tail\n    '
    pass

def first(seq):
    "first(seq)\n\n    The first element in a sequence\n\n    >>> first('ABC')\n    'A'\n    "
    pass

def frequencies(seq):
    "frequencies(seq) -> dict\n\n    Find number of occurrences of each value in seq\n\n    >>> frequencies(['cat', 'cat', 'ox', 'pig', 'pig', 'cat'])  #doctest: +SKIP\n    {'cat': 3, 'ox': 1, 'pig': 2}\n\n    See Also:\n        countby\n        groupby\n    "
    return dict()

def get(ind, seq, default):
    "get(ind, seq, default='__no__default__')\n\n    Get element in a sequence or dict\n\n    Provides standard indexing\n\n    >>> get(1, 'ABC')       # Same as 'ABC'[1]\n    'B'\n\n    Pass a list to get multiple values\n\n    >>> get([1, 2], 'ABC')  # ('ABC'[1], 'ABC'[2])\n    ('B', 'C')\n\n    Works on any value that supports indexing/getitem\n    For example here we see that it works with dictionaries\n\n    >>> phonebook = {'Alice':  '555-1234',\n    ...              'Bob':    '555-5678',\n    ...              'Charlie':'555-9999'}\n    >>> get('Alice', phonebook)\n    '555-1234'\n\n    >>> get(['Alice', 'Bob'], phonebook)\n    ('555-1234', '555-5678')\n\n    Provide a default for missing values\n\n    >>> get(['Alice', 'Dennis'], phonebook, None)\n    ('555-1234', None)\n\n    See Also:\n        pluck\n    "
    pass

def getter(index):
    'getter(index)'
    pass

def groupby(key, seq):
    "groupby(key, seq) -> dict\n\n    Group a collection by a key function\n\n    >>> names = ['Alice', 'Bob', 'Charlie', 'Dan', 'Edith', 'Frank']\n    >>> groupby(len, names)  # doctest: +SKIP\n    {3: ['Bob', 'Dan'], 5: ['Alice', 'Edith', 'Frank'], 7: ['Charlie']}\n\n    >>> iseven = lambda x: x % 2 == 0\n    >>> groupby(iseven, [1, 2, 3, 4, 5, 6, 7, 8])  # doctest: +SKIP\n    {False: [1, 3, 5, 7], True: [2, 4, 6, 8]}\n\n    Non-callable keys imply grouping on a member.\n\n    >>> groupby('gender', [{'name': 'Alice', 'gender': 'F'},\n    ...                    {'name': 'Bob', 'gender': 'M'},\n    ...                    {'name': 'Charlie', 'gender': 'M'}]) # doctest:+SKIP\n    {'F': [{'gender': 'F', 'name': 'Alice'}],\n     'M': [{'gender': 'M', 'name': 'Bob'},\n           {'gender': 'M', 'name': 'Charlie'}]}\n\n    See Also:\n        countby\n    "
    return dict()

def heapify():
    'Transform list into a heap, in-place, in O(len(heap)) time.'
    pass

def heappop():
    'Pop the smallest item off the heap, maintaining the heap invariant.'
    pass

def heapreplace(heap, item):
    'heapreplace(heap, item) -> value. Pop and return the current smallest value, and add the new item.\n\nThis is more efficient than heappop() followed by heappush(), and can be\nmore appropriate when using a fixed-size heap.  Note that the value\nreturned may be larger than item!  That constrains reasonable uses of\nthis routine unless written as part of a conditional replacement:\n\n    if item > heap[0]:\n        item = heapreplace(heap, item)\n'
    pass

def identity(x):
    'identity(x)'
    pass

class interleave(_mod_builtins.object):
    " interleave(seqs)\n\n    Interleave a sequence of sequences\n\n    >>> list(interleave([[1, 2], [3, 4]]))\n    [1, 3, 2, 4]\n\n    >>> ''.join(interleave(('ABC', 'XY')))\n    'AXBYC'\n\n    Both the individual sequences and the sequence of sequences may be infinite\n\n    Returns a lazy iterator\n    "
    __class__ = interleave
    def __init__(self, seqs):
        " interleave(seqs)\n\n    Interleave a sequence of sequences\n\n    >>> list(interleave([[1, 2], [3, 4]]))\n    [1, 3, 2, 4]\n\n    >>> ''.join(interleave(('ABC', 'XY')))\n    'AXBYC'\n\n    Both the individual sequences and the sequence of sequences may be infinite\n\n    Returns a lazy iterator\n    "
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return interleave()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'interleave.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'interleave.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class interpose(_mod_builtins.object):
    ' interpose(el, seq)\n\n    Introduce element between each pair of elements in seq\n\n    >>> list(interpose("a", [1, 2, 3]))\n    [1, \'a\', 2, \'a\', 3]\n    '
    __class__ = interpose
    def __init__(self, el, seq):
        ' interpose(el, seq)\n\n    Introduce element between each pair of elements in seq\n\n    >>> list(interpose("a", [1, 2, 3]))\n    [1, \'a\', 2, \'a\', 3]\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return interpose()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'interpose.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'interpose.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def isdistinct(seq):
    'isdistinct(seq)\n\n    All values in sequence are distinct\n\n    >>> isdistinct([1, 2, 3])\n    True\n    >>> isdistinct([1, 2, 1])\n    False\n\n    >>> isdistinct("Hello")\n    False\n    >>> isdistinct("World")\n    True\n    '
    pass

def isiterable(x):
    "isiterable(x)\n\n    Is x iterable?\n\n    >>> isiterable([1, 2, 3])\n    True\n    >>> isiterable('abc')\n    True\n    >>> isiterable(5)\n    False\n    "
    pass

islice = _mod_itertools.islice
itemgetter = _mod_operator.itemgetter
class iterate(_mod_builtins.object):
    ' iterate(func, x)\n\n    Repeatedly apply a function func onto an original input\n\n    Yields x, then func(x), then func(func(x)), then func(func(func(x))), etc..\n\n    >>> def inc(x):  return x + 1\n    >>> counter = iterate(inc, 0)\n    >>> next(counter)\n    0\n    >>> next(counter)\n    1\n    >>> next(counter)\n    2\n\n    >>> double = lambda x: x * 2\n    >>> powers_of_two = iterate(double, 1)\n    >>> next(powers_of_two)\n    1\n    >>> next(powers_of_two)\n    2\n    >>> next(powers_of_two)\n    4\n    >>> next(powers_of_two)\n    8\n    '
    __class__ = iterate
    def __init__(self, func, x):
        ' iterate(func, x)\n\n    Repeatedly apply a function func onto an original input\n\n    Yields x, then func(x), then func(func(x)), then func(func(func(x))), etc..\n\n    >>> def inc(x):  return x + 1\n    >>> counter = iterate(inc, 0)\n    >>> next(counter)\n    0\n    >>> next(counter)\n    1\n    >>> next(counter)\n    2\n\n    >>> double = lambda x: x * 2\n    >>> powers_of_two = iterate(double, 1)\n    >>> next(powers_of_two)\n    1\n    >>> next(powers_of_two)\n    2\n    >>> next(powers_of_two)\n    4\n    >>> next(powers_of_two)\n    8\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return iterate()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'iterate.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'iterate.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def join(leftkey, leftseq, rightkey, rightseq, left_default, right_default):
    "join(leftkey, leftseq, rightkey, rightseq, left_default='__no__default__', right_default='__no__default__')\n\n    Join two sequences on common attributes\n\n    This is a semi-streaming operation.  The LEFT sequence is fully evaluated\n    and placed into memory.  The RIGHT sequence is evaluated lazily and so can\n    be arbitrarily large.\n\n    >>> friends = [('Alice', 'Edith'),\n    ...            ('Alice', 'Zhao'),\n    ...            ('Edith', 'Alice'),\n    ...            ('Zhao', 'Alice'),\n    ...            ('Zhao', 'Edith')]\n\n    >>> cities = [('Alice', 'NYC'),\n    ...           ('Alice', 'Chicago'),\n    ...           ('Dan', 'Syndey'),\n    ...           ('Edith', 'Paris'),\n    ...           ('Edith', 'Berlin'),\n    ...           ('Zhao', 'Shanghai')]\n\n    >>> # Vacation opportunities\n    >>> # In what cities do people have friends?\n    >>> result = join(second, friends,\n    ...               first, cities)\n    >>> for ((a, b), (c, d)) in sorted(unique(result)):\n    ...     print((a, d))\n    ('Alice', 'Berlin')\n    ('Alice', 'Paris')\n    ('Alice', 'Shanghai')\n    ('Edith', 'Chicago')\n    ('Edith', 'NYC')\n    ('Zhao', 'Chicago')\n    ('Zhao', 'NYC')\n    ('Zhao', 'Berlin')\n    ('Zhao', 'Paris')\n\n    Specify outer joins with keyword arguments ``left_default`` and/or\n    ``right_default``.  Here is a full outer join in which unmatched elements\n    are paired with None.\n\n    >>> identity = lambda x: x\n    >>> list(join(identity, [1, 2, 3],\n    ...           identity, [2, 3, 4],\n    ...           left_default=None, right_default=None))\n    [(2, 2), (3, 3), (None, 4), (1, None)]\n\n    Usually the key arguments are callables to be applied to the sequences.  If\n    the keys are not obviously callable then it is assumed that indexing was\n    intended, e.g. the following is a legal change\n\n    >>> # result = join(second, friends, first, cities)\n    >>> result = join(1, friends, 0, cities)  # doctest: +SKIP\n    "
    pass

def last(seq):
    "last(seq)\n\n    The last element in a sequence\n\n    >>> last('ABC')\n    'C'\n    "
    pass

map = _mod_builtins.map
def mapcat(func, seqs):
    'mapcat(func, seqs)\n\n    Apply func to each sequence in seqs, concatenating results.\n\n    >>> list(mapcat(lambda s: [c.upper() for c in s],\n    ...             [["a", "b"], ["c", "d", "e"]]))\n    [\'A\', \'B\', \'C\', \'D\', \'E\']\n    '
    pass

def merge_sorted(*seqs, **kwargs):
    'merge_sorted(*seqs, **kwargs)\n\n    Merge and sort a collection of sorted collections\n\n    This works lazily and only keeps one value from each iterable in memory.\n\n    >>> list(merge_sorted([1, 3, 5], [2, 4, 6]))\n    [1, 2, 3, 4, 5, 6]\n\n    >>> \'\'.join(merge_sorted(\'abc\', \'abc\', \'abc\'))\n    \'aaabbbccc\'\n\n    The "key" function used to sort the input may be passed as a keyword.\n\n    >>> list(merge_sorted([2, 3], [1, 3], key=lambda x: x // 3))\n    [2, 1, 3, 3]\n    '
    pass

no_default = '__no__default__'
no_pad = '__no__pad__'
def nth(n, seq):
    "nth(Py_ssize_t n, seq)\n\n    The nth element in a sequence\n\n    >>> nth(1, 'ABC')\n    'B'\n    "
    pass

def partition(n, seq, pad):
    "partition(Py_ssize_t n, seq, pad='__no__pad__')\n\n    Partition sequence into tuples of length n\n\n    >>> list(partition(2, [1, 2, 3, 4]))\n    [(1, 2), (3, 4)]\n\n    If the length of ``seq`` is not evenly divisible by ``n``, the final tuple\n    is dropped if ``pad`` is not specified, or filled to length ``n`` by pad:\n\n    >>> list(partition(2, [1, 2, 3, 4, 5]))\n    [(1, 2), (3, 4)]\n\n    >>> list(partition(2, [1, 2, 3, 4, 5], pad=None))\n    [(1, 2), (3, 4), (5, None)]\n\n    See Also:\n        partition_all\n    "
    pass

class partition_all(_mod_builtins.object):
    ' partition_all(n, seq)\n\n    Partition all elements of sequence into tuples of length at most n\n\n    The final tuple may be shorter to accommodate extra elements.\n\n    >>> list(partition_all(2, [1, 2, 3, 4]))\n    [(1, 2), (3, 4)]\n\n    >>> list(partition_all(2, [1, 2, 3, 4, 5]))\n    [(1, 2), (3, 4), (5,)]\n\n    See Also:\n        partition\n    '
    __class__ = partition_all
    def __init__(self, n, seq):
        ' partition_all(n, seq)\n\n    Partition all elements of sequence into tuples of length at most n\n\n    The final tuple may be shorter to accommodate extra elements.\n\n    >>> list(partition_all(2, [1, 2, 3, 4]))\n    [(1, 2), (3, 4)]\n\n    >>> list(partition_all(2, [1, 2, 3, 4, 5]))\n    [(1, 2), (3, 4), (5,)]\n\n    See Also:\n        partition\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return partition_all()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'partition_all.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'partition_all.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def peek(seq):
    'peek(seq)\n\n    Retrieve the next element of a sequence\n\n    Returns the first element and an iterable equivalent to the original\n    sequence, still having the element retrieved.\n\n    >>> seq = [0, 1, 2, 3, 4]\n    >>> first, seq = peek(seq)\n    >>> first\n    0\n    >>> list(seq)\n    [0, 1, 2, 3, 4]\n    '
    pass

def pluck(ind, seqs, default):
    "pluck(ind, seqs, default='__no__default__')\n\n    plucks an element or several elements from each item in a sequence.\n\n    ``pluck`` maps ``itertoolz.get`` over a sequence and returns one or more\n    elements of each item in the sequence.\n\n    This is equivalent to running `map(curried.get(ind), seqs)`\n\n    ``ind`` can be either a single string/index or a list of strings/indices.\n    ``seqs`` should be sequence containing sequences or dicts.\n\n    e.g.\n\n    >>> data = [{'id': 1, 'name': 'Cheese'}, {'id': 2, 'name': 'Pies'}]\n    >>> list(pluck('name', data))\n    ['Cheese', 'Pies']\n    >>> list(pluck([0, 1], [[1, 2, 3], [4, 5, 7]]))\n    [(1, 2), (4, 5)]\n\n    See Also:\n        get\n        map\n    "
    pass

class random_sample(_mod_builtins.object):
    ' random_sample(prob, seq, random_state=None)\n\n    Return elements from a sequence with probability of prob\n\n    Returns a lazy iterator of random items from seq.\n\n    ``random_sample`` considers each item independently and without\n    replacement. See below how the first time it returned 13 items and the\n    next time it returned 6 items.\n\n    >>> seq = list(range(100))\n    >>> list(random_sample(0.1, seq)) # doctest: +SKIP\n    [6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95]\n    >>> list(random_sample(0.1, seq)) # doctest: +SKIP\n    [6, 44, 54, 61, 69, 94]\n\n    Providing an integer seed for ``random_state`` will result in\n    deterministic sampling. Given the same seed it will return the same sample\n    every time.\n\n    >>> list(random_sample(0.1, seq, random_state=2016))\n    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98]\n    >>> list(random_sample(0.1, seq, random_state=2016))\n    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98]\n\n    ``random_state`` can also be any object with a method ``random`` that\n    returns floats between 0.0 and 1.0 (exclusive).\n\n    >>> from random import Random\n    >>> randobj = Random(2016)\n    >>> list(random_sample(0.1, seq, random_state=randobj))\n    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98]\n    '
    __class__ = random_sample
    def __init__(self, prob, seq, random_state=None):
        ' random_sample(prob, seq, random_state=None)\n\n    Return elements from a sequence with probability of prob\n\n    Returns a lazy iterator of random items from seq.\n\n    ``random_sample`` considers each item independently and without\n    replacement. See below how the first time it returned 13 items and the\n    next time it returned 6 items.\n\n    >>> seq = list(range(100))\n    >>> list(random_sample(0.1, seq)) # doctest: +SKIP\n    [6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95]\n    >>> list(random_sample(0.1, seq)) # doctest: +SKIP\n    [6, 44, 54, 61, 69, 94]\n\n    Providing an integer seed for ``random_state`` will result in\n    deterministic sampling. Given the same seed it will return the same sample\n    every time.\n\n    >>> list(random_sample(0.1, seq, random_state=2016))\n    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98]\n    >>> list(random_sample(0.1, seq, random_state=2016))\n    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98]\n\n    ``random_state`` can also be any object with a method ``random`` that\n    returns floats between 0.0 and 1.0 (exclusive).\n\n    >>> from random import Random\n    >>> randobj = Random(2016)\n    >>> list(random_sample(0.1, seq, random_state=randobj))\n    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98]\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return random_sample()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'random_sample.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'random_sample.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def reduceby(key, binop, seq, init):
    "reduceby(key, binop, seq, init='__no__default__') -> dict\n\n    Perform a simultaneous groupby and reduction\n\n    The computation:\n\n    >>> result = reduceby(key, binop, seq, init)      # doctest: +SKIP\n\n    is equivalent to the following:\n\n    >>> def reduction(group):                           # doctest: +SKIP\n    ...     return reduce(binop, group, init)           # doctest: +SKIP\n\n    >>> groups = groupby(key, seq)                    # doctest: +SKIP\n    >>> result = valmap(reduction, groups)              # doctest: +SKIP\n\n    But the former does not build the intermediate groups, allowing it to\n    operate in much less space.  This makes it suitable for larger datasets\n    that do not fit comfortably in memory\n\n    The ``init`` keyword argument is the default initialization of the\n    reduction.  This can be either a constant value like ``0`` or a callable\n    like ``lambda : 0`` as might be used in ``defaultdict``.\n\n    Simple Examples\n    ---------------\n\n    >>> from operator import add, mul\n    >>> iseven = lambda x: x % 2 == 0\n\n    >>> data = [1, 2, 3, 4, 5]\n\n    >>> reduceby(iseven, add, data)  # doctest: +SKIP\n    {False: 9, True: 6}\n\n    >>> reduceby(iseven, mul, data)  # doctest: +SKIP\n    {False: 15, True: 8}\n\n    Complex Example\n    ---------------\n\n    >>> projects = [{'name': 'build roads', 'state': 'CA', 'cost': 1000000},\n    ...             {'name': 'fight crime', 'state': 'IL', 'cost': 100000},\n    ...             {'name': 'help farmers', 'state': 'IL', 'cost': 2000000},\n    ...             {'name': 'help farmers', 'state': 'CA', 'cost': 200000}]\n\n    >>> reduceby('state',                        # doctest: +SKIP\n    ...          lambda acc, x: acc + x['cost'],\n    ...          projects, 0)\n    {'CA': 1200000, 'IL': 2100000}\n\n    Example Using ``init``\n    ----------------------\n\n    >>> def set_add(s, i):\n    ...     s.add(i)\n    ...     return s\n\n    >>> reduceby(iseven, set_add, [1, 2, 3, 4, 1, 2, 3], set)  # doctest: +SKIP\n    {True:  set([2, 4]),\n     False: set([1, 3])}\n    "
    return dict()

class remove(_mod_builtins.object):
    ' remove(predicate, seq)\n\n    Return those items of sequence for which predicate(item) is False\n\n    >>> def iseven(x):\n    ...     return x % 2 == 0\n    >>> list(remove(iseven, [1, 2, 3, 4]))\n    [1, 3]\n    '
    __class__ = remove
    def __init__(self, predicate, seq):
        ' remove(predicate, seq)\n\n    Return those items of sequence for which predicate(item) is False\n\n    >>> def iseven(x):\n    ...     return x % 2 == 0\n    >>> list(remove(iseven, [1, 2, 3, 4]))\n    [1, 3]\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return remove()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'remove.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'remove.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def rest(seq):
    'rest(seq)'
    pass

def second(seq):
    "second(seq)\n\n    The second element in a sequence\n\n    >>> second('ABC')\n    'B'\n    "
    pass

class sliding_window(_mod_builtins.object):
    ' sliding_window(n, seq)\n\n    A sequence of overlapping subsequences\n\n    >>> list(sliding_window(2, [1, 2, 3, 4]))\n    [(1, 2), (2, 3), (3, 4)]\n\n    This function creates a sliding window suitable for transformations like\n    sliding means / smoothing\n\n    >>> mean = lambda seq: float(sum(seq)) / len(seq)\n    >>> list(map(mean, sliding_window(2, [1, 2, 3, 4])))\n    [1.5, 2.5, 3.5]\n    '
    __class__ = sliding_window
    def __init__(self, n, seq):
        ' sliding_window(n, seq)\n\n    A sequence of overlapping subsequences\n\n    >>> list(sliding_window(2, [1, 2, 3, 4]))\n    [(1, 2), (2, 3), (3, 4)]\n\n    This function creates a sliding window suitable for transformations like\n    sliding means / smoothing\n\n    >>> mean = lambda seq: float(sum(seq)) / len(seq)\n    >>> list(map(mean, sliding_window(2, [1, 2, 3, 4])))\n    [1.5, 2.5, 3.5]\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self):
        'Implement iter(self).'
        return sliding_window()
    
    def __next__(self):
        pass
    
    def __reduce__(self):
        'sliding_window.__reduce_cython__(self)'
        return ''; return ()
    
    def __setstate__(self, state):
        'sliding_window.__setstate_cython__(self, __pyx_state)'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def tail(n, seq):
    'tail(Py_ssize_t n, seq)\n\n    The last n elements of a sequence\n\n    >>> tail(2, [10, 20, 30, 40, 50])\n    [40, 50]\n\n    See Also:\n        drop\n        take\n    '
    pass

def take(n, seq):
    'take(Py_ssize_t n, seq)\n\n    The first n elements of a sequence\n\n    >>> list(take(2, [10, 20, 30, 40, 50]))\n    [10, 20]\n\n    See Also:\n        drop\n        tail\n    '
    pass

def take_nth(n, seq):
    'take_nth(Py_ssize_t n, seq)\n\n    Every nth item in seq\n\n    >>> list(take_nth(2, [10, 20, 30, 40, 50]))\n    [10, 30, 50]\n    '
    pass

def topk(k, seq, key):
    "topk(Py_ssize_t k, seq, key=None)\n\n    Find the k largest elements of a sequence\n\n    Operates lazily in ``n*log(k)`` time\n\n    >>> topk(2, [1, 100, 10, 1000])\n    (1000, 100)\n\n    Use a key function to change sorted order\n\n    >>> topk(2, ['Alice', 'Bob', 'Charlie', 'Dan'], key=len)\n    ('Charlie', 'Alice')\n\n    See also:\n        heapq.nlargest\n    "
    pass

def unique(seq, key):
    "unique(seq, key=None)\n\n    Return only unique elements of a sequence\n\n    >>> tuple(unique((1, 2, 3)))\n    (1, 2, 3)\n    >>> tuple(unique((1, 2, 1, 3)))\n    (1, 2, 3)\n\n    Uniqueness can be defined by key keyword\n\n    >>> tuple(unique(['cat', 'mouse', 'dog', 'hen'], key=len))\n    ('cat', 'mouse')\n    "
    pass

zip = _mod_builtins.zip
zip_longest = _mod_itertools.zip_longest
