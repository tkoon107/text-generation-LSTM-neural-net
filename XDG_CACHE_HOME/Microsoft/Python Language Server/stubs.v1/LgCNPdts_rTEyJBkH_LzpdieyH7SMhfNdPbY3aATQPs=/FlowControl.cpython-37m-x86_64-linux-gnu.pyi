import Cython.Compiler.Optimize as _mod_Cython_Compiler_Optimize
import Cython.Compiler.Visitor as _mod_Cython_Compiler_Visitor
import builtins as _mod_builtins

class Argument(NameAssignment):
    __class__ = Argument
    __dict__ = {}
    def __init__(self, lhs, rhs, entry):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    

class AssignmentCollector(_mod_Cython_Compiler_Visitor.TreeVisitor):
    __class__ = AssignmentCollector
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def visit_CascadedAssignmentNode(self, node):
        pass
    
    def visit_Node(self):
        pass
    
    def visit_SingleAssignmentNode(self, node):
        pass
    

class AssignmentList(_mod_builtins.object):
    __class__ = AssignmentList
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def bit(self):
        pass
    
    @property
    def mask(self):
        pass
    
    @property
    def stats(self):
        pass
    

ConstantFolding = _mod_Cython_Compiler_Optimize.ConstantFolding
class ControlBlock(_mod_builtins.object):
    "Control flow graph node. Sequence of assignments and name references.\n\n       children  set of children nodes\n       parents   set of parent nodes\n       positions set of position markers\n\n       stats     list of block statements\n       gen       dict of assignments generated by this block\n       bounded   set  of entries that are definitely bounded in this block\n\n       Example:\n\n        a = 1\n        b = a + c # 'c' is already bounded or exception here\n\n        stats = [Assignment(a), NameReference(a), NameReference(c),\n                     Assignment(b)]\n        gen = {Entry(a): Assignment(a), Entry(b): Assignment(b)}\n        bounded = set([Entry(a), Entry(c)])\n\n    "
    __class__ = ControlBlock
    def __init__(self, *args, **kwargs):
        "Control flow graph node. Sequence of assignments and name references.\n\n       children  set of children nodes\n       parents   set of parent nodes\n       positions set of position markers\n\n       stats     list of block statements\n       gen       dict of assignments generated by this block\n       bounded   set  of entries that are definitely bounded in this block\n\n       Example:\n\n        a = 1\n        b = a + c # 'c' is already bounded or exception here\n\n        stats = [Assignment(a), NameReference(a), NameReference(c),\n                     Assignment(b)]\n        gen = {Entry(a): Assignment(a), Entry(b): Assignment(b)}\n        bounded = set([Entry(a), Entry(c)])\n\n    "
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def add_child(self, block):
        pass
    
    @property
    def bounded(self):
        pass
    
    @property
    def children(self):
        pass
    
    def detach(self):
        'Detach block from parents and children.'
        pass
    
    def empty(self):
        pass
    
    @property
    def gen(self):
        pass
    
    @property
    def i_gen(self):
        pass
    
    @property
    def i_input(self):
        pass
    
    @property
    def i_kill(self):
        pass
    
    @property
    def i_output(self):
        pass
    
    @property
    def i_state(self):
        pass
    
    @property
    def input(self):
        pass
    
    @property
    def output(self):
        pass
    
    @property
    def parents(self):
        pass
    
    @property
    def positions(self):
        pass
    
    @property
    def stats(self):
        pass
    

class ControlFlow(_mod_builtins.object):
    'Control-flow graph.\n\n       entry_point ControlBlock entry point for this graph\n       exit_point  ControlBlock normal exit point\n       block       ControlBlock current block\n       blocks      set    children nodes\n       entries     set    tracked entries\n       loops       list   stack for loop descriptors\n       exceptions  list   stack for exception descriptors\n    '
    __class__ = ControlFlow
    def __init__(self, *args, **kwargs):
        'Control-flow graph.\n\n       entry_point ControlBlock entry point for this graph\n       exit_point  ControlBlock normal exit point\n       block       ControlBlock current block\n       blocks      set    children nodes\n       entries     set    tracked entries\n       loops       list   stack for loop descriptors\n       exceptions  list   stack for exception descriptors\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def assmts(self):
        pass
    
    @property
    def block(self):
        pass
    
    @property
    def blocks(self):
        pass
    
    @property
    def entries(self):
        pass
    
    @property
    def entry_point(self):
        pass
    
    @property
    def exceptions(self):
        pass
    
    @property
    def exit_point(self):
        pass
    
    def initialize(self):
        'Set initial state, map assignments to bits.'
        pass
    
    def is_statically_assigned(self, entry):
        pass
    
    def is_tracked(self, entry):
        pass
    
    @property
    def loops(self):
        pass
    
    def map_one(self, istate, entry):
        pass
    
    def mark_argument(self, lhs, rhs, entry):
        pass
    
    def mark_assignment(self, lhs, rhs, entry):
        pass
    
    def mark_deletion(self, node, entry):
        pass
    
    def mark_position(self, node):
        'Mark position, will be used to draw graph nodes.'
        pass
    
    def mark_reference(self, node, entry):
        pass
    
    def newblock(self, parent):
        'Create floating block linked to `parent` if given.\n\n           NOTE: Block is NOT added to self.blocks\n        '
        pass
    
    def nextblock(self, parent):
        'Create block children block linked to current or `parent` if given.\n\n           NOTE: Block is added to self.blocks\n        '
        pass
    
    def normalize(self):
        'Delete unreachable and orphan blocks.'
        pass
    

class ControlFlowAnalysis(_mod_Cython_Compiler_Visitor.CythonTransform):
    __class__ = ControlFlowAnalysis
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def _delete_privates(self, node, exclude):
        pass
    
    def mark_assignment(self, lhs, rhs):
        pass
    
    def mark_forloop_target(self, node):
        pass
    
    def mark_position(self, node):
        'Mark position if DOT output is enabled.'
        pass
    
    def visit_AmpersandNode(self, node):
        pass
    
    def visit_AssignmentNode(self, node):
        pass
    
    def visit_AsyncForStatNode(self, node):
        pass
    
    def visit_BreakStatNode(self, node):
        pass
    
    def visit_CArgDeclNode(self, node):
        pass
    
    def visit_CTypeDefNode(self, node):
        pass
    
    def visit_CascadedAssignmentNode(self, node):
        pass
    
    def visit_ComprehensionNode(self, node):
        pass
    
    def visit_ContinueStatNode(self, node):
        pass
    
    def visit_DefNode(self, node):
        pass
    
    def visit_DelStatNode(self, node):
        pass
    
    def visit_ForFromStatNode(self, node):
        pass
    
    def visit_ForInStatNode(self, node):
        pass
    
    def visit_FromImportStatNode(self, node):
        pass
    
    def visit_FuncDefNode(self, node):
        pass
    
    def visit_GeneratorBodyDefNode(self, node):
        pass
    
    def visit_IfStatNode(self, node):
        pass
    
    def visit_InPlaceAssignmentNode(self, node):
        pass
    
    def visit_LoopNode(self, node):
        pass
    
    def visit_ModuleNode(self, node):
        pass
    
    def visit_NameNode(self, node):
        pass
    
    def visit_Node(self, node):
        pass
    
    def visit_ParallelAssignmentNode(self, node):
        pass
    
    def visit_ParallelRangeNode(self, node):
        pass
    
    def visit_ParallelWithBlockNode(self, node):
        pass
    
    def visit_PyClassDefNode(self, node):
        pass
    
    def visit_RaiseStatNode(self, node):
        pass
    
    def visit_ReraiseStatNode(self, node):
        pass
    
    def visit_ReturnStatNode(self, node):
        pass
    
    def visit_ScopedExprNode(self, node):
        pass
    
    def visit_SingleAssignmentNode(self, node):
        pass
    
    def visit_StatListNode(self, node):
        pass
    
    def visit_TryExceptStatNode(self, node):
        pass
    
    def visit_TryFinallyStatNode(self, node):
        pass
    
    def visit_WhileStatNode(self, node):
        pass
    
    def visit_WithStatNode(self, node):
        pass
    
    def visit_WithTargetAssignmentStatNode(self, node):
        pass
    

class ControlFlowState(_mod_builtins.list):
    __class__ = ControlFlowState
    __dict__ = {}
    def __init__(self, state):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'Cython.Compiler.FlowControl'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    cf_is_null = False
    cf_maybe_null = False
    is_single = False
    def one(self):
        pass
    

class ExceptionDescr(_mod_builtins.object):
    'Exception handling helper.\n\n    entry_point   ControlBlock Exception handling entry point\n    finally_enter ControlBlock Normal finally clause entry point\n    finally_exit  ControlBlock Normal finally clause exit point\n    '
    __class__ = ExceptionDescr
    __dict__ = {}
    def __init__(self, entry_point, finally_enter, finally_exit):
        'Exception handling helper.\n\n    entry_point   ControlBlock Exception handling entry point\n    finally_enter ControlBlock Normal finally clause entry point\n    finally_exit  ControlBlock Normal finally clause exit point\n    '
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'Cython.Compiler.FlowControl'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    

class ExitBlock(ControlBlock):
    'Non-empty exit point block.'
    __class__ = ExitBlock
    def __init__(self, *args, **kwargs):
        'Non-empty exit point block.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __pyx_vtable__ = _mod_builtins.PyCapsule()
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def empty(self):
        pass
    

class GV(_mod_builtins.object):
    'Graphviz DOT renderer.'
    __class__ = GV
    __dict__ = {}
    def __init__(self, name, flow):
        'Graphviz DOT renderer.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'Cython.Compiler.FlowControl'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    def render(self, fp, ctx, annotate_defs):
        pass
    

class GVContext(_mod_builtins.object):
    'Graphviz subgraph object.'
    __class__ = GVContext
    __dict__ = {}
    def __init__(self):
        'Graphviz subgraph object.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'Cython.Compiler.FlowControl'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    def add(self, child):
        pass
    
    def escape(self, text):
        pass
    
    def extract_sources(self, block):
        pass
    
    def nodeid(self, block):
        pass
    
    def render(self, fp, name, annotate_defs):
        'Render graphviz dot graph'
        pass
    

class LoopDescr(_mod_builtins.object):
    __class__ = LoopDescr
    __dict__ = {}
    def __init__(self, next_block, loop_block):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'Cython.Compiler.FlowControl'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    

class MessageCollection(_mod_builtins.object):
    'Collect error/warnings messages first then sort'
    __class__ = MessageCollection
    def __init__(self, *args, **kwargs):
        'Collect error/warnings messages first then sort'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def error(self, pos, message):
        pass
    
    def report(self):
        pass
    
    def warning(self, pos, message):
        pass
    

class NameAssignment(_mod_builtins.object):
    __class__ = NameAssignment
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def bit(self):
        pass
    
    @property
    def entry(self):
        pass
    
    def infer_type(self):
        pass
    
    @property
    def inferred_type(self):
        pass
    
    @property
    def is_arg(self):
        pass
    
    @property
    def is_deletion(self):
        pass
    
    @property
    def lhs(self):
        pass
    
    @property
    def pos(self):
        pass
    
    @property
    def refs(self):
        pass
    
    @property
    def rhs(self):
        pass
    
    @property
    def type(self):
        pass
    
    def type_dependencies(self):
        pass
    

class NameDeletion(NameAssignment):
    __class__ = NameDeletion
    __dict__ = {}
    def __init__(self, lhs, entry):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    def infer_type(self):
        pass
    

class NameReference(_mod_builtins.object):
    __class__ = NameReference
    __dict__ = {}
    def __init__(self, node, entry):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'Cython.Compiler.FlowControl'
    def __repr__(self):
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    

class StaticAssignment(NameAssignment):
    'Initialised at declaration time, e.g. stack allocation.'
    __class__ = StaticAssignment
    __dict__ = {}
    def __init__(self, entry):
        'Initialised at declaration time, e.g. stack allocation.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    def infer_type(self):
        pass
    
    def type_dependencies(self):
        pass
    

class Uninitialized(_mod_builtins.object):
    'Definitely not initialised yet.'
    __class__ = Uninitialized
    def __init__(self, *args, **kwargs):
        'Definitely not initialised yet.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class Unknown(_mod_builtins.object):
    'Coming from outer closure, might be initialised or not.'
    __class__ = Unknown
    def __init__(self, *args, **kwargs):
        'Coming from outer closure, might be initialised or not.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __reduce__(self):
        return ''; return ()
    
    def __setstate__(self, state):
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

__builtins__ = {}
__doc__ = None
__file__ = '/home/trevor/anaconda3/lib/python3.7/site-packages/Cython/Compiler/FlowControl.cpython-37m-x86_64-linux-gnu.so'
__name__ = 'Cython.Compiler.FlowControl'
__package__ = 'Cython.Compiler'
__pyx_capi__ = _mod_builtins.dict()
def __pyx_unpickle_AssignmentCollector(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_AssignmentList(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_ControlBlock(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_ControlFlow(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_ControlFlowAnalysis(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_ExitBlock(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_MessageCollection(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_NameAssignment(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_Uninitialized(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __pyx_unpickle_Unknown(__pyx_type, __pyx_checksum, __pyx_state):
    pass

def __reduce_cython__(self):
    pass

def __setstate_cython__(self, __pyx_state):
    pass

__test__ = _mod_builtins.dict()
